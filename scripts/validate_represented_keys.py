"""
compare_keys.py

Usage:
  python compare_keys.py path/to/file.cpp path/to/file.ts output.md

Scans the C++ and TypeScript files for key definitions, compares them,
and writes a Markdown report listing keys only in C++ and only in TypeScript.

C++ pattern expected (examples):
  {"A", KeyCode::A},
  { "Enter", KeyCode::Enter },

TypeScript pattern expected (examples, examined only inside the region
between `//#region keys` and `//#endregion`):
  Numpad5 = 'Numpad5',
  Exclamation = '!',
  Quote = "'",
  Backslash = '\\'
The TS parsing correctly captures one-character string literals (including quotes).
"""

import re
import sys
from pathlib import Path

# match C++ entries like: {"A", KeyCode::A},
CPP_PATTERN = re.compile(
    r'\{\s*["\'](?P<label>[^"\']+)["\']\s*,\s*KeyCode::(?P<key>[A-Za-z0-9_]+)\s*\}\s*,?'
)

# match TS entries like: Numpad5 = 'Numpad5', or Exclamation = '!'
# Capture the RHS string literal in group 'label' and the LHS identifier in 'key'.
TS_PATTERN = re.compile(r'(?P<key>[A-Za-z0-9_]+)\s*=\s*(?P<quote>["\'])(?P<label>(?:\\.|(?!\2).)*?)\2')



REGION_START = re.compile(r'//\s*#region\s+keys')
REGION_END = re.compile(r'//\s*#endregion')

def extract_cpp_labels(text):
    """Return set of string labels from C++ entries like {"A", KeyCode::A}."""
    return {m.group('label') for m in CPP_PATTERN.finditer(text)}

def extract_ts_region(text):
    """Return the substring between //#region keys and //#endregion.
    If not found, return entire text (backwards compatible).
    """
    start = REGION_START.search(text)
    if not start:
        return text
    end = REGION_END.search(text, start.end())
    if not end:
        return text[start.end():]
    return text[start.end():end.start()]

def unescape_ts_string(s):
    """Basic unescape for common JS escapes to produce the actual character(s)."""
    # Use unicode-escape via latin-1 trick after replacing JS-style escapes where needed.
    # This handles sequences like \n, \t, \', \", \\ and \xNN and \uNNNN.
    # It's not a full JS parser but covers typical cases used for single-character keys.
    s = s.replace(r"\'", "'").replace(r'\"', '"').replace(r'\\', '\\')
    # handle \xNN and \uNNNN and \u{...}
    def repl_x(m):
        return chr(int(m.group(1), 16))
    s = re.sub(r'\\x([0-9A-Fa-f]{2})', repl_x, s)
    s = re.sub(r'\\u\{([0-9A-Fa-f]+)\}', lambda m: chr(int(m.group(1), 16)), s)
    s = re.sub(r'\\u([0-9A-Fa-f]{4})', repl_x, s)
    # common escapes
    s = s.replace(r'\n', '\n').replace(r'\r', '\r').replace(r'\t', '\t')
    return s

def extract_ts_keys(text):
    """Return set of string labels extracted from TS file (RHS string literals),
    but only within the keys region if present. Also returns a mapping label->key.
    """
    region = extract_ts_region(text)
    labels = set()
    label_to_key = {}
    for m in TS_PATTERN.finditer(region):
        lhs = m.group('key') if m.groupdict().get('key') else None
        raw_label = m.group('label')
        label = unescape_ts_string(raw_label)
        labels.add(label)
        if lhs:
            label_to_key[label] = lhs
    return labels, label_to_key

def read_file(path):
    return Path(path).read_text(encoding='utf-8')

def write_markdown(out_path, only_cpp, only_ts):
    parts = []
    parts.append("# Key Comparison Report\n\n")
    parts.append("Generated by compare_keys.py\n\n")
    parts.append("## Keys present in C++ but not in TypeScript\n\n")
    if only_cpp:
        for k in sorted(only_cpp):
            parts.append(f"- **{k}**\n")
    else:
        parts.append("None. ✅\n")
    parts.append("\n## Keys present in TypeScript but not in C++\n\n")
    if only_ts:
        for k in sorted(only_ts):
            parts.append(f"- **{k}**\n")
    else:
        parts.append("None. ✅\n")
    Path(out_path).write_text(''.join(parts), encoding='utf-8')

def main():
    if len(sys.argv) != 3:
        print("Usage: python compare_keys.py path/to/file.cpp path/to/file.ts")
        sys.exit(2)

    cpp_path, ts_path = sys.argv[1], sys.argv[2]
    out_path = './output.md'

    cpp_text = read_file(cpp_path)
    ts_text = read_file(ts_path)

    cpp_labels = extract_cpp_labels(cpp_text)
    ts_labels, ts_label_map = extract_ts_keys(ts_text)

    only_cpp = cpp_labels - ts_labels      # labels in C++ but not TS
    only_ts = ts_labels - cpp_labels      # labels in TS but not C++

    write_markdown(out_path, only_cpp, only_ts)

    print(f"Report written to {out_path}")
    if only_cpp:
        print(f"Keys only in C++ ({len(only_cpp)}): {sorted(only_cpp)[:10]}{'...' if len(only_cpp)>10 else ''}")
    if only_ts:
        print(f"Keys only in TS ({len(only_ts)}): {sorted(only_ts)[:10]}{'...' if len(only_ts)>10 else ''}")

if __name__ == '__main__':
    main()